// Code generated by mockery v2.20.0. DO NOT EDIT.

package mocks

import (
	context "context"

	credentials "github.com/vmware-tanzu/velero/internal/credentials"
	datapath "github.com/vmware-tanzu/velero/pkg/datapath"

	mock "github.com/stretchr/testify/mock"

	repository "github.com/vmware-tanzu/velero/pkg/repository"
)

// AsyncBR is an autogenerated mock type for the AsyncBR type
type AsyncBR struct {
	mock.Mock
}

// Cancel provides a mock function with given fields:
func (_m *AsyncBR) Cancel() {
	_m.Called()
}

// Close provides a mock function with given fields: ctx
func (_m *AsyncBR) Close(ctx context.Context) {
	_m.Called(ctx)
}

// Init provides a mock function with given fields: ctx, bslName, sourceNamespace, uploaderType, repositoryType, repoIdentifier, repositoryEnsurer, credentialGetter
func (_m *AsyncBR) Init(ctx context.Context, bslName string, sourceNamespace string, uploaderType string, repositoryType string, repoIdentifier string, repositoryEnsurer *repository.Ensurer, credentialGetter *credentials.CredentialGetter) error {
	ret := _m.Called(ctx, bslName, sourceNamespace, uploaderType, repositoryType, repoIdentifier, repositoryEnsurer, credentialGetter)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, *repository.Ensurer, *credentials.CredentialGetter) error); ok {
		r0 = rf(ctx, bslName, sourceNamespace, uploaderType, repositoryType, repoIdentifier, repositoryEnsurer, credentialGetter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StartBackup provides a mock function with given fields: source, realSource, parentSnapshot, forceFull, tags
func (_m *AsyncBR) StartBackup(source datapath.AccessPoint, realSource string, parentSnapshot string, forceFull bool, tags map[string]string) error {
	ret := _m.Called(source, realSource, parentSnapshot, forceFull, tags)

	var r0 error
	if rf, ok := ret.Get(0).(func(datapath.AccessPoint, string, string, bool, map[string]string) error); ok {
		r0 = rf(source, realSource, parentSnapshot, forceFull, tags)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StartRestore provides a mock function with given fields: snapshotID, target
func (_m *AsyncBR) StartRestore(snapshotID string, target datapath.AccessPoint) error {
	ret := _m.Called(snapshotID, target)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, datapath.AccessPoint) error); ok {
		r0 = rf(snapshotID, target)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewAsyncBR interface {
	mock.TestingT
	Cleanup(func())
}

// NewAsyncBR creates a new instance of AsyncBR. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewAsyncBR(t mockConstructorTestingTNewAsyncBR) *AsyncBR {
	mock := &AsyncBR{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
